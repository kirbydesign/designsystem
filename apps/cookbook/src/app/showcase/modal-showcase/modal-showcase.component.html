<div class="example-wrapper">
  <div>
    <p>
      A Modal is a dialog that appears on top of the app's content, and must be dismissed by the app
      before interaction can resume. It is useful as a select component when there are a lot of
      options to choose from, or when filtering items in a list, as well as many other use cases.
    </p>
    <ul>
      <li>
        A modal can be opened through
        <a href="#" (click)="scrollTo(modalController)"><code>ModalController</code></a>
      </li>
      <li>
        The modal comes in 3 different <a href="#" (click)="scrollTo(modalFlavors)">flavors</a>:
        <ul>
          <li><a href="#" (click)="scrollTo(modalFlavorsModal)">Modal (default)</a></li>
          <li><a href="#" (click)="scrollTo(modalFlavorsCompact)">Compact</a></li>
          <li><a href="#" (click)="scrollTo(modalFlavorsDrawer)">Drawer</a></li>
        </ul>
      </li>
      <li>
        Support for handling the
        <a href="#" (click)="scrollTo(didPresentEvent)">didPresent event</a>
      </li>
      <li>Support for handling the <a href="#" (click)="scrollTo(closeEvent)">close event</a></li>
      <li>
        Support for <a href="#" (click)="scrollTo(returnData)">returning data</a> from the modal to
        the parent/caller component
      </li>
      <li>Support for <a href="#" (click)="scrollTo(scrolling)">scrolling</a></li>
      <li>
        Support for <a href="#" (click)="scrollTo(disableScrolling)">disabling of scrolling</a>
      </li>
      <li>(Optional) <a href="#" (click)="scrollTo(footer)">Fixed footer</a></li>
    </ul>
    <h2><span class="desktop">Desktop:</span><span class="mobile">Mobile:</span></h2>
    <cookbook-modal-example #example></cookbook-modal-example>
    <cookbook-code-viewer [html]="example.template"></cookbook-code-viewer>
  </div>
  <cookbook-iphone src="/examples/modal" showExternalLink="true"></cookbook-iphone>
</div>
<h2 #modalController>Inside the parent (caller) component:</h2>
<p>
  To show the modal, create a <code>ModalConfig</code> and pass it to the
  <code>ModalController.showModal</code> method:
  <cookbook-code-viewer [ts]="example.defaultCodeSnippet"></cookbook-code-viewer>
</p>
<h2 #modalFlavors>Modal flavors:</h2>
<p>
  The modal can have one of multiple flavors, used to determine the opening animation, the position
  of the title and the close button.
</p>
<h3 #modalFlavorsModal>Modal (default)</h3>
<p>
  With the <strong><code>modal</code></strong> flavor, the dialog opens with a slide-up animation,
  it's title is aligned to the left and it's close button is placed in the top right corner. The
  modal includes a gesture to drag the modal down to close it.<br />
  On mobile/small screens the presenting page will be pushed back in a card-like style (when used
  inside a <code>kirby-app</code>). Any additional modals with the <code>modal</code> flavor opened
  on top will also scale/push back the existing modal, similar to a card stack.
</p>
<h3 #modalFlavorsCompact>Compact</h3>
<p>
  The <strong><code>compact</code></strong> flavor renders a stripped-down version with no heading,
  toolbar or close button and no content scrolling. Can be used for <em>out-of-order</em> style
  modals.
</p>
<h3 #modalFlavorsDrawer>Drawer</h3>
<p>
  When a <strong><code>drawer</code></strong> flavor is used, the dialog opens with a slide-up
  animation, it's title is centered and it's close button is placed in the top left corner.
  Additionally, with the <code>drawer</code> flavor, users can specify a
  <code>drawerSupplementaryAction</code>, which is an additional button rendered in the top right
  corner (see the example below). The <code>drawerSupplementaryAction</code> option takes an
  <code>iconName: string</code> which corresponds to the name of a kirby icon, and
  <code>action: Function</code>, which is invoked when the supplementary button is selected.
  <cookbook-code-viewer [ts]="example.drawerCodeSnippet"></cookbook-code-viewer>
</p>
<h2 #closeEvent>Close event handler <em>(optional)</em>:</h2>
<p>
  If you want to be notified when the modal closes, you can pass a callback function:
  <cookbook-code-viewer [ts]="example.callbackCodeSnippet"></cookbook-code-viewer>
</p>
<h2 #returnData>Return data from the modal <em>(optional)</em>:</h2>
<p>
  If you need to obtain data back from the modal, you can pass a callback function:
  <cookbook-code-viewer [ts]="example.callbackWithDataCodeSnippet"></cookbook-code-viewer>
</p>

<h2>Inside the embedded component:</h2>
<p>To create an embedded component, ensure:</p>
<ol>
  <li>
    the embedded component must be declared (module file, or inside your
    <code>@Component</code> decorator)
  </li>
  <li>the embedded component must be listed in your <code>entryComponents</code> (module file)</li>
</ol>
<br />
<em>(Optional)</em><br />
<p>
  To access data passed into the embedded component, inject the
  <code>COMPONENT_PROPS</code> inside the embedded component's constructor:
</p>
<cookbook-code-viewer [ts]="example.embeddedCodeSnippet"></cookbook-code-viewer><br />
<p>
  In order to hide a modal from within your embedded component (and destroy it's component), you can
  inject the modal window that your component is displayed within:
  <cookbook-code-viewer [ts]="example.closeModalCodeSnippet"></cookbook-code-viewer>
  It is possible to nest more modals from within your embedded components, by using the same
  services and principles as above.
</p>

<h2 #didPresentEvent>Modal presented</h2>
<p>
  The <code>Modal</code> fires the <code>didPresent</code> event, when the modal is ready and the
  enter animation has finished. This is a good place to hook up any visual initialization of the
  embedded component, e.g. setting focus in an input field:
</p>
<cookbook-code-viewer [ts]="example.didPresentCodeSnippet"></cookbook-code-viewer>

<h2 #willCloseEvent>Modal Closing</h2>
<p>
  The <code>Modal</code> fires the <code>willClose</code> event, when the modal is starting to
  dismiss/close before any animations occurs. This gives you a slot to execute your exceptional code
  just when the modal starts closing but before its actually done:
</p>
<cookbook-code-viewer [ts]="example.willCloseCodeSnippet"></cookbook-code-viewer>

<h2 #scrolling>Scrolling</h2>
<p>
  The <code>Modal</code> supports scrolling to the top and bottom of the modal using the methods
  <code>scrollToTop</code> and <code>scrollToBottom</code>. They accept
  <code>KirbyAnimation.Duration</code> as optional param. If not provided the scrolling will happen
  instantaneously.
</p>
<cookbook-code-viewer [ts]="example.scrollingCodeSnippet"></cookbook-code-viewer>

<h3 #disableScrolling>Disable scrolling</h3>
<p>
  The <code>Modal</code> supports disabling of scrolling by setting the property
  <code>scrollDisabled = true</code>
</p>
<cookbook-code-viewer [ts]="example.disableScrollingCodeSnippet"></cookbook-code-viewer>

<h2 #footer>Footer</h2>
<p>
  To render a fixed footer at the bottom of the modal include a
  <code>kirby-modal-footer</code> inside the embedded component:
</p>
<cookbook-code-viewer [html]="example.footerTemplate"></cookbook-code-viewer>

<p>
  If the <code>snapToKeyboard</code> attribute is set to true, the modal footer will slide upwards
  with the soft keyboard on mobile devices to make it stay visible. If omitted, or if explicitly set
  to false, the modal footer will stay at the bottom and the keyboard will slide in on top of it.
</p>

<h2>Modal config:</h2>
<cookbook-showcase-properties [properties]="configProperties"></cookbook-showcase-properties>

<h2>Modal properties:</h2>
<cookbook-showcase-properties [properties]="properties"></cookbook-showcase-properties>

<h2>Modal footer properties:</h2>
<cookbook-showcase-properties [properties]="footerProperties"></cookbook-showcase-properties>

<h2>Events:</h2>
<h3><code>Modal</code></h3>
<cookbook-showcase-properties
  [properties]="events"
  [columns]="eventColumns"
></cookbook-showcase-properties>
