import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import path from 'path';
import prettier from 'prettier';
import { ESLint } from 'eslint';

import {
  eventToPropertyName,
  getElementMetadata,
  getJsdocDescription,
  getJsdocDescriptionDeprecated,
  getJsdocElementSummary,
} from './utils/cem-helper-functions';
import { LitCustomElement } from './utils';

/********** Script execution **********/

const LIB_PATH = 'libs/core';
const ANGULAR_LIB_PATH = 'libs/angular';
const GENERATED_COMPONENT_START_REGION = '// START_OF_AUTO_GENERATED_COMPONENT';
const CORE_PACKAGE_JSON = JSON.parse(
  readFileSync(path.resolve(`${LIB_PATH}/package.json`), 'utf8'),
);

const elementMetadata: LitCustomElement[] = getElementMetadata(LIB_PATH);

elementMetadata.forEach(async (element) => {
  await generateProxyComponent(element).catch((error) => {
    console.error(error);
  });
});

/********** Helper functions **********/

async function generateProxyComponent(element: LitCustomElement) {
  const { tagNameWithoutPrefix } = element;
  const componentDir = `${ANGULAR_LIB_PATH}/${tagNameWithoutPrefix}/src`;
  const componentFile = `${componentDir}/${tagNameWithoutPrefix}.component.ts`;
  const componentPublicApi = `${componentDir}/public_api.ts`;

  const componentSource = await generateComponentSource(element);
  const publicApiSource = await generatePublicApiSource(element);

  if (!componentSource) {
    throw new Error(`Failed to generate proxy component for ${tagNameWithoutPrefix}.`);
  }
  if (!publicApiSource) {
    throw new Error(`Failed to generate public_api.ts for ${tagNameWithoutPrefix}.`);
  }

  let componentSourceWithImports = getTypeImports(element) + componentSource;

  if (existsSync(componentFile)) {
    componentSourceWithImports = mergeExistingImports(
      componentFile,
      componentSourceWithImports,
      componentSource,
    );
  }

  const formattedComponentSource = await formatWithEslint(
    componentSourceWithImports,
    tagNameWithoutPrefix,
  );

  mkdirSync(componentDir, { recursive: true });
  writeFileSync(componentPublicApi, publicApiSource, 'utf8');
  writeFileSync(componentFile, formattedComponentSource, 'utf8');
}

function mergeExistingImports(
  componentFile: string,
  componentSourceWithImports: string,
  componentSource: string,
) {
  const existingComponent = readFileSync(componentFile, 'utf8');
  const autoGeneratedComponentStartIndex = existingComponent.indexOf(
    GENERATED_COMPONENT_START_REGION,
  );

  if (autoGeneratedComponentStartIndex !== -1) {
    const imports = existingComponent.substring(
      0,
      autoGeneratedComponentStartIndex + GENERATED_COMPONENT_START_REGION.length,
    );
    componentSourceWithImports = `${imports}\n${componentSource}`;
  }
  return componentSourceWithImports;
}

function getTypeImports(element: LitCustomElement) {
  const elementEntryPoint = `'${CORE_PACKAGE_JSON.name}/${element.tagNameWithoutPrefix}'`;

  return `import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Output } from '@angular/core';
    import type { ${element.name} } from ${elementEntryPoint};
    ${GENERATED_COMPONENT_START_REGION}`;
}

function getInputProperties(element: LitCustomElement) {
  if (!element.properties) return '';
  return element.properties
    .map(
      (property) => `
        ${getJsdocDescription(property)} ${getJsdocDescriptionDeprecated(property)}
        @Input()
        set ${property.name}(v: ${property.type?.text}) {
          this.ngZone.runOutsideAngular(() => (this.el.${property.name} = v));
        }

        get ${property.name}(): ${property.type?.text} {
          return this.el.${property.name};
        }`,
    )
    .join('\n');
}

function getOutputProperties(element: LitCustomElement) {
  if (!element.events) return '';
  return element.events
    .map((event) => `@Output() ${eventToPropertyName(event.name)} = new EventEmitter<unknown>();`)
    .join('\n');
}

function getEventListeners(element: LitCustomElement) {
  if (!element.events) return '';
  return element.events
    .map(
      (event) => `
        this._el.addEventListener('${event.name}', (e: Event) => {
          this.${eventToPropertyName(event.name)}.emit(e);
        });`,
    )
    .join('\n');
}

async function formatWithPrettier(code: string) {
  const filePath = await prettier.resolveConfigFile();
  if (!filePath) return code;
  const options = await prettier.resolveConfig(filePath);
  return prettier.format(code, { ...options, parser: 'typescript' });
}

async function generateComponentSource(element: LitCustomElement) {
  const { name, tagName } = element;
  const angularComponentName = name.replace('Element', 'Component');

  const componentSource = `${getJsdocElementSummary(element)}
    // AUTO-GENERATED - Any missing type imports can be added manually above, but do not change component source
    @Component({
      selector: '${tagName}',
      template: '<ng-content></ng-content>',
      standalone: true,
      changeDetection: ChangeDetectionStrategy.OnPush,
    })
    export class ${angularComponentName} {
      private el: ${name};

      constructor(private e: ElementRef<${name}>, private ngZone: NgZone, private cdr: ChangeDetectorRef) {
        this.el = this.e.nativeElement;
        this.cdr.detach();

        ${getEventListeners(element)}
      }

      ${getInputProperties(element)}
      ${getOutputProperties(element)}
    }`;

  return componentSource;
}

async function generatePublicApiSource(element: LitCustomElement) {
  const { name, tagNameWithoutPrefix } = element;
  return formatWithPrettier(`
    // AUTO-GENERATED - PLEASE DON'T EDIT THIS FILE MANUALLY.
    import { ${name} } from '${CORE_PACKAGE_JSON.name}/${tagNameWithoutPrefix}.element';
    export * from './${tagNameWithoutPrefix}.component';
    ${name}.define();
  `);
}

async function formatWithEslint(unformattedSource: string, tagNameWithoutPrefix: string) {
  const eslint = new ESLint({
    fix: true,
    overrideConfigFile: path.resolve('tools/eslint-config/angular.json'),
  });
  const lintingResults = await eslint.lintText(unformattedSource, { filePath: 'component.ts' });

  if (lintingResults.length > 0 && lintingResults[0].output) {
    return lintingResults[0].output;
  }

  console.warn(`${tagNameWithoutPrefix} component source was not formatted by ESLint.`);

  return unformattedSource;
}
