import * as ts from 'typescript';
import * as prettier from 'prettier';

import { readFileSync, writeFileSync, readdirSync, statSync, existsSync } from 'fs';

type ComponentMetaData = {
  className: string;
  decorator: string;
  selector: string;
  properties: any[];
};

export class GenerateMocks {
  private readonly outputPath = './libs/designsystem/testing/src/lib';
  async renderMocks(rootPath) {
    const classMap = new Map<string, string[]>();
    await this.traverseFolder(rootPath, classMap);
    await this.renderMockComponentDeclaration(classMap);
  }

  private async renderMockComponentDeclaration(classMap: Map<string, string[]>) {
    const imports = Array.from(classMap.entries())
      .map((keyValue) => {
        const path = keyValue[0];
        const classNames = keyValue[1];
        const relativePath = path.replace(this.outputPath, '.').replace('.ts', '');
        return `import { ${classNames.join(', ')} } from '${relativePath}';`;
      })
      .join('\n');
    const components = Array.from(classMap.values())
      .map((classNames) => classNames.join(',\n  '))
      .join(',\n  ');
    const filename = `${this.outputPath}/mock-components.ts`;
    const content = `${imports}

export const MOCK_COMPONENTS = [
  ${components},
];
`;
    const formatted = await this.formatWithPrettier(content);
    writeFileSync(filename, formatted);
  }

  private async traverseFolder(path: string, classMap: Map<string, string[]>) {
    const folderContent = readdirSync(path);
    for (const fileOrFolder of folderContent) {
      const fullPath = path + fileOrFolder;
      const ent = statSync(fullPath);
      if (ent.isDirectory()) {
        await this.traverseFolder(fullPath + '/', classMap);
      } else {
        if (fileOrFolder.endsWith('.component.ts')) {
          // console.log('Rendering mock for: ', fullPath);
          const mockFileName = 'mock.' + fullPath.substr(fullPath.lastIndexOf('/') + 1);
          const mockFilePath = `${this.outputPath}/components/`;
          const newFilename = mockFilePath + mockFileName;
          const classNames = await this.renderMock(fullPath, newFilename);
          if (classNames) {
            classMap.set(newFilename, classNames);
          }
        }
      }
    }
  }

  private async renderMock(fileName: string, newFilename: string) {
    const components = this.generateMetaData(fileName);
    if (!components.find((metaData) => metaData.decorator)) {
      // Nothing to generate:
      return;
    }
    const rendered = [];
    const classNames = [];
    const imports = this.getImports(components);
    components.forEach((metaData) => {
      const mockClassName = 'Mock' + metaData.className;
      classNames.push(mockClassName);
      const classDeclaration = this.renderClass(mockClassName, metaData);
      rendered.push(classDeclaration);
    });
    const importStatement = `import { ${imports.join(', ')} } from '@angular/core';\n\n`;
    const startRegion = '// #region AUTO-GENERATED';
    const endRegion = '// #endregion';
    const autoGeneratedContent = `${startRegion} - PLEASE DON'T EDIT CONTENT WITHIN!
${rendered.join('\n')}
${endRegion}
`;
    let content = importStatement + autoGeneratedContent;
    if (existsSync(newFilename)) {
      const existingContent = readFileSync(newFilename).toString();
      const regionStartIndex = existingContent.indexOf(startRegion);
      const beforeRegion = existingContent.substring(0, regionStartIndex);
      content = beforeRegion + autoGeneratedContent;
    }
    const formatted = await this.formatWithPrettier(content);
    writeFileSync(newFilename, formatted);
    return classNames;
  }

  private renderClass(mockClassName: string, componentMetaData: ComponentMetaData): string {
    const propertiesString = this.renderProperties(componentMetaData.properties);
    const validSelector =
      componentMetaData.selector &&
      (componentMetaData.selector.startsWith(`'kirby`) ||
        componentMetaData.selector.startsWith(`'[kirby`));
    const tsLintDisableSelector =
      componentMetaData.selector && !validSelector
        ? `\n  // tslint:disable-next-line: component-selector`
        : '';
    const selector = componentMetaData.selector
      ? `\n  selector: ${componentMetaData.selector},`
      : '';
    const template =
      componentMetaData.decorator === 'Component'
        ? `\n  template: '<ng-content></ng-content>',`
        : '';
    const content = `@${componentMetaData.decorator}({${tsLintDisableSelector}${selector}${template}
})
export class ${mockClassName} {${propertiesString}}
`;
    return content;
  }

  private getImports(components: ComponentMetaData[]): string[] {
    const imports = [];
    if (components.some((metaData) => metaData.decorator === 'Component')) {
      imports.push('Component');
    }
    if (components.some((metaData) => metaData.decorator === 'Directive')) {
      imports.push('Directive');
    }
    const hasInputOutput = (metaData: ComponentMetaData, direction: string) =>
      metaData.properties.some((prop) => prop.direction === direction);
    const hasInput = (metaData) => hasInputOutput(metaData, 'input');
    const hasOutput = (metaData) => hasInputOutput(metaData, 'output');
    if (components.some(hasInput)) {
      imports.push('Input');
    }
    if (components.some(hasOutput)) {
      imports.push('Output', 'EventEmitter');
    }
    return imports;
  }

  private renderProperties(properties: any[]) {
    let renderedProps = properties.map((prop) => {
      switch (prop.direction) {
        case 'input':
          const typeDeclaration = prop.type ? `: ${prop.type}` : '';
          return `@Input() ${prop.name}${typeDeclaration};`;
        case 'output':
          const initializer = prop.initializer || `new ${prop.type || 'EventEmitter'}()`;
          return `@Output() ${prop.name} = ${initializer};`;
      }
    });
    const separator = '\n  ';
    return renderedProps.length ? separator + renderedProps.join(separator) + '\n' : '';
  }

  private generateMetaData(fileName: string) {
    const sourceFile = ts.createSourceFile(
      fileName,
      readFileSync(fileName).toString(),
      ts.ScriptTarget.ES2015,
      /*setParentNodes */ true
    );
    const components = [];
    sourceFile.forEachChild((node) => {
      switch (node.kind) {
        case ts.SyntaxKind.ClassDeclaration: {
          const componentMetaData = { className: '', decorator: '', selector: '', properties: [] };
          this.visitTree(node, componentMetaData);
          if (componentMetaData.decorator) {
            components.push(componentMetaData);
          }
          break;
        }
      }
    });
    // this.visitTree(sourceFile, componentMetaData);
    return components;
  }

  private visitTree(node: ts.Node, componentMetaData?: ComponentMetaData) {
    switch (node.kind) {
      case ts.SyntaxKind.ClassDeclaration: {
        this.visitClassDeclaration(node as ts.ClassDeclaration, componentMetaData);
        break;
      }
      case ts.SyntaxKind.PropertyDeclaration:
      case ts.SyntaxKind.SetAccessor: {
        const propertyDeclaration = node as ts.PropertyDeclaration;
        this.visitPropertyDeclaration(propertyDeclaration, componentMetaData);
        break;
      }
    }
    ts.forEachChild(node, (node) => this.visitTree(node, componentMetaData));
  }

  private visitClassDeclaration(
    classDeclaration: ts.ClassDeclaration,
    componentMetaData: ComponentMetaData
  ) {
    const className = classDeclaration.name.getText();
    componentMetaData.className = className;
    if (classDeclaration && classDeclaration.decorators) {
      classDeclaration.decorators.forEach((decorator) => {
        switch (decorator.expression.kind) {
          case ts.SyntaxKind.CallExpression:
            const decoratorExpression = decorator.expression as ts.CallExpression;
            switch (decoratorExpression.expression.kind) {
              case ts.SyntaxKind.Identifier:
                const identifier = decoratorExpression.expression as ts.Identifier;
                const decoratorName = identifier.getText();
                if (decoratorName === 'Component' || decoratorName === 'Directive') {
                  componentMetaData.decorator = decoratorName;
                  const args = decoratorExpression.arguments[0] as ts.ObjectLiteralExpression;
                  const selectorArg = args.properties.find(
                    (prop) => prop.name.getText() === 'selector'
                  ) as ts.PropertyAssignment;
                  if (selectorArg) {
                    const selector = selectorArg.initializer.getText();
                    componentMetaData.selector = selector;
                  }
                }
                break;
            }
            break;
        }
      });
    }
  }

  private visitPropertyDeclaration(
    propertyDeclaration: ts.PropertyDeclaration,
    componentMetaData: ComponentMetaData
  ) {
    const propertyDeclarationText = propertyDeclaration.getText();
    let initializer: string;
    if (propertyDeclaration.initializer) {
      initializer = propertyDeclaration.initializer.getText();
    }
    const isInput = propertyDeclarationText.startsWith('@Input');
    const isOutput = propertyDeclarationText.startsWith('@Output');

    const name = propertyDeclaration.name.getText();
    const type = propertyDeclaration.type ? propertyDeclaration.type.getText() : undefined;
    const prop = {
      name,
      type,
      initializer,
      direction: isInput ? 'input' : isOutput ? 'output' : undefined,
    };
    if (isInput || isOutput) {
      componentMetaData.properties.push(prop);
    }
  }

  private async formatWithPrettier(code: string) {
    const filePath = await prettier.resolveConfigFile();
    const options = await prettier.resolveConfig(filePath);
    return prettier.format(code, { ...options, parser: 'typescript' });
  }
}
